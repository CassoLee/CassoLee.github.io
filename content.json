[{"title":"","date":"2019-01-25T06:23:08.450Z","path":"2019/01/25/java实现图片合成/","text":"title: java实现图片合成date: 2019-01-25 14:23:08tags:package com.tourstock.marketing.utils.wish;import java.awt.BasicStroke;import java.awt.Color;import java.awt.Font;import java.awt.FontMetrics;import java.awt.Graphics2D;import java.awt.Shape;import java.awt.geom.RoundRectangle2D;import java.awt.image.BufferedImage;import java.io.File;import java.util.Hashtable;import java.util.LinkedHashMap;import java.util.Map;import java.util.Map.Entry; import javax.imageio.ImageIO; import org.apache.log4j.Logger; import com.google.zxing.BarcodeFormat;import com.google.zxing.EncodeHintType;import com.google.zxing.MultiFormatWriter;import com.google.zxing.WriterException;import com.google.zxing.client.j2se.MatrixToImageWriter;import com.google.zxing.common.BitMatrix;import com.google.zxing.qrcode.decoder.ErrorCorrectionLevel;import com.tourstock.common.util.Json; /** 二维码工具类 */public class QRCodeUtil { private static Logger logger = Logger.getLogger(QRCodeUtil.class); private static final String CHARSET = “utf-8”; private static final String FORMAT_NAME = “JPG”; public static String GenarateImage(String content, ErrorCorrectionLevel level) throws Exception { String topic = &quot;我有一个心愿&quot;; String words = &quot;旅游&quot;; String partner = &quot;朋友&quot;; String destination = &quot;纽约&quot;; String sentence = &quot;我想带%s去%s&quot;; Map&lt;String,Object[]&gt; wishInfoMap = new LinkedHashMap&lt;String,Object[]&gt;(); wishInfoMap.put(sentence, new String[] {partner, destination}); wishInfoMap.put(words, new String[] {}); wishInfoMap.put(&quot;&quot;, new String[] {topic}); String fileUrl = &quot;D:\\\\BaiduNetdiskDownload\\\\&quot; + &quot;lulutrip.jpg&quot;; File file = new File(fileUrl); BufferedImage bgp = ImageIO.read(file); int bgpWidth = bgp.getWidth(null); int qrCodeSize = (int) (bgpWidth*0.35); BufferedImage qr = genarateQrCode(content, qrCodeSize, level); insertImage(bgp, qr, wishInfoMap); ImageIO.write(bgp, FORMAT_NAME, new File(&quot;D:\\\\BaiduNetdiskDownload&quot;+&quot;\\\\&quot;+&quot;lulutripcopy.jpg&quot;)); // ByteArrayOutputStream bos = new ByteArrayOutputStream(); // ImageIO.write(bgp, FORMAT_NAME, bos);//利用ImageIO类提供的write方法，以图片的数据模式写入流 // byte b[] = bos.toByteArray(); // return Base64.getEncoder().encodeToString(b); return null; } public static BufferedImage genarateQrCode(String content, int qrCodeSize, ErrorCorrectionLevel level) throws WriterException{ Hashtable&lt;EncodeHintType, Object&gt; hints = new Hashtable&lt;EncodeHintType, Object&gt;(); hints.put(EncodeHintType.ERROR_CORRECTION, level); hints.put(EncodeHintType.CHARACTER_SET, CHARSET); hints.put(EncodeHintType.MARGIN, 0); BitMatrix bitMatrix = new MultiFormatWriter().encode(content, BarcodeFormat.QR_CODE, qrCodeSize, qrCodeSize, hints); BufferedImage image = MatrixToImageWriter.toBufferedImage(bitMatrix); return image; } private static void insertImage(BufferedImage bgp, BufferedImage qr,Map&lt;String,Object[]&gt; wishInfoMap) throws Exception { if (qr==null) { logger.error(&quot;二维码图片不存在！&quot;); return; } int bgpWidth = bgp.getWidth(null); int bgpHeight = bgp.getHeight(null); // 插入二维码 Graphics2D graph = bgp.createGraphics(); int QRCODE_X = (int) (bgpWidth*0.333); int QRCODE_Y = (int) (bgpHeight*0.557); graph.drawImage(qr, QRCODE_X, QRCODE_Y, qr.getWidth(null), qr.getWidth(null), null); Shape shape = new RoundRectangle2D.Float(QRCODE_X, QRCODE_Y, bgpWidth, bgpWidth, 6, 6); graph.setStroke(new BasicStroke(3f)); graph.draw(shape); //插入心愿信息 Font font = DefinedFont.getDefinedFont(&quot;FZMiaoWuJ&quot;, 180.0f); graph.setFont(font); int wishInfoY = (int) (bgpHeight*0.52); for(Entry&lt;String, Object[]&gt; entry : wishInfoMap.entrySet()) { int lineWords = getLineWords(graph, bgpWidth); Map&lt;Integer, LinkedHashMap&lt;Integer, Integer&gt;&gt; criticalIndexMap = getCriticalIndexMap(lineWords, entry.getKey(), entry.getValue()); String sentence = String.format(entry.getKey(), entry.getValue()); LinkedHashMap&lt;Integer, Integer&gt; lineIndexMap = getLineIndexMap(lineWords, sentence); wishInfoY = drawWishInfo(graph, bgpWidth, wishInfoY, sentence, lineIndexMap, criticalIndexMap); } graph.dispose(); } private static int drawWishInfo(Graphics2D graph, int bgpWidth, Integer wishInfoY, String sentence, LinkedHashMap&lt;Integer, Integer&gt; lineIndexMap, Map&lt;Integer, LinkedHashMap&lt;Integer, Integer&gt;&gt;criticalIndexMap) { Font font = graph.getFont(); FontMetrics metrics = graph.getFontMetrics(font); int lineNum = lineIndexMap.size()-1;//倒数第一行 for(Entry&lt;Integer, Integer&gt; entry : lineIndexMap.entrySet()) { int drawIndex = 0; String lineWord = sentence.substring(entry.getKey(), entry.getValue()+1); int drawWidth = metrics.stringWidth(lineWord); int wishInfoX = (bgpWidth-drawWidth)/2; LinkedHashMap&lt;Integer, Integer&gt; criticalMap = criticalIndexMap.get(lineNum); if(criticalMap!=null &amp;&amp; criticalMap.size()&gt;0) { for(Entry&lt;Integer, Integer&gt; criticalEntry : criticalMap.entrySet()) { int criticalStart = criticalEntry.getKey(); int criticalEnd = criticalEntry.getValue(); if(drawIndex != criticalEntry.getKey()){ graph.setColor(new Color(255, 255, 255)); String drawWord = lineWord.substring(drawIndex, criticalStart); graph.drawString(drawWord, wishInfoX, wishInfoY); drawIndex = criticalStart; wishInfoX += metrics.stringWidth(drawWord); } graph.setColor(new Color(255, 244, 0)); String drawWord = lineWord.substring(drawIndex, criticalEnd+1); graph.drawString(drawWord, wishInfoX, wishInfoY); drawIndex = criticalEnd+1; wishInfoX += metrics.stringWidth(drawWord); } } else { graph.setColor(new Color(255, 255, 255)); graph.drawString(lineWord, wishInfoX, wishInfoY); } lineNum--;//向上一行 wishInfoY -= metrics.getHeight();//向上一行后的垂直高度 } return wishInfoY; } private static LinkedHashMap&lt;Integer, Integer&gt; getLineIndexMap(int lineWords, String wishInfo){ LinkedHashMap&lt;Integer, Integer&gt; indexMap = new LinkedHashMap&lt;Integer, Integer&gt;(); int len = wishInfo.length(); for(int i=len;i&gt;=0;i--) { if(i%lineWords==0) { int endIndex = i+lineWords-1; if(endIndex &gt; len-1) { endIndex = len-1; } indexMap.put(i, endIndex); } } return indexMap; } private static Map&lt;Integer, LinkedHashMap&lt;Integer, Integer&gt;&gt; getCriticalIndexMap(int lineWords, String sentence, Object... words) { String wishInfo = String.format(sentence, words); Map&lt;Integer, LinkedHashMap&lt;Integer, Integer&gt;&gt; criticalIndexMap = new LinkedHashMap&lt;Integer, LinkedHashMap&lt;Integer, Integer&gt;&gt;(); if(words != null &amp;&amp; words.length &gt; 0) { for(int i=0; i&lt;words.length; i++) { String word = String.valueOf(words[i]); int startIndex = wishInfo.indexOf(word);//关键词开始位置 int lineNum = startIndex/lineWords;//关键词所在行数 int wordLen = word.length(); int endIndex = startIndex + wordLen - 1;//关键词结束位置 if(startIndex + 1 &gt; lineWords || endIndex+1 &gt; lineWords) { int lineStartIndex = startIndex%lineWords; while(lineNum&lt;=endIndex/lineWords) { if(lineNum == endIndex/lineWords) {//最后一行 putMap(criticalIndexMap, lineNum, lineStartIndex, endIndex%lineWords); } else { putMap(criticalIndexMap, lineNum, lineStartIndex, lineWords-1); } lineNum++; lineStartIndex = 0; } } else { putMap(criticalIndexMap, lineNum, startIndex, endIndex); } } } return criticalIndexMap; } private static void putMap(Map&lt;Integer, LinkedHashMap&lt;Integer, Integer&gt;&gt; criticalIndexMap, int lineNum, int startIndex, int endIndex) { if(criticalIndexMap.get(lineNum) == null) { criticalIndexMap.put(lineNum, new LinkedHashMap&lt;Integer, Integer&gt;()); } criticalIndexMap.get(lineNum).put(startIndex, endIndex); } private static int getLineWords(Graphics2D graph, int bgpWidth) { Font font = graph.getFont(); FontMetrics metrics = graph.getFontMetrics(font); int len = 0; StringBuffer sb = new StringBuffer(); while(metrics.stringWidth(sb.append(&quot;路&quot;).toString()) &lt;= bgpWidth) { len++; } return len; } /** * 当文件夹不存在时，mkdirs会自动创建多层目录，区别于mkdir．(mkdir如果父目录不存在则会抛出异常) * @author lanyuan * Email: mmm333zzz520@163.com * @date 2013-12-11 上午10:16:36 * @param destPath 存放目录 */ public static void mkdirs(String destPath) { File file =new File(destPath); //当文件夹不存在时，mkdirs会自动创建多层目录，区别于mkdir．(mkdir如果父目录不存在则会抛出异常) if (!file.exists() &amp;&amp; !file.isDirectory()) { file.mkdirs(); } } public static void main(String[] args) throws Exception { String text = &quot;http://www.lulutrip.com&quot;; // QRCodeUtil.createImage(text, new URL(&quot;http://www.quimg.com/m/logo/logo60x60.png&quot;), false); System.out.println(QRCodeUtil.GenarateImage(text,ErrorCorrectionLevel.M)); // String sentence = &quot;我想带%s去%s&quot;; // Map&lt;String,Object[]&gt; wishInfoMap = new HashMap&lt;String,Object[]&gt;(); // wishInfoMap.put(sentence, new String[] {&quot;朋友&quot;, &quot;纽约&quot;}); // Map&lt;Integer, LinkedHashMap&lt;Integer, Integer&gt;&gt; map = getCriticalIndexMap(5, sentence, new String[] {&quot;朋友&quot;, &quot;纽约&quot;}); // LinkedHashMap&lt;Integer, Integer&gt; m = getLineIndexMap(5, “我有一个心愿”); // System.out.println(Json.toJson(map));// System.out.println(Json.toJson(m)); }}—","tags":[]},{"title":"spring cloud 组件","date":"2018-12-29T09:54:12.000Z","path":"2018/12/29/spring-cloud-组件/","text":"Spring Cloud技术应用从场景上可以分为两大类：润物无声类和独挑大梁类。 润物无声，融合在每个微服务中、依赖其它组件并为其提供服务。 Ribbon，客户端负载均衡，特性有区域亲和、重试机制。 Hystrix，客户端容错保护，特性有服务降级、服务熔断、请求缓存、请求合并、依赖隔离。 Feign，声明式服务调用，本质上就是Ribbon+Hystrix Stream，消息驱动，有Sink、Source、Processor三种通道，特性有订阅发布、消费组、消息分区。 Bus，消息总线，配合Config仓库修改的一种Stream实现， Sleuth，分布式服务追踪，需要搞清楚TraceID和SpanID以及抽样，如何与ELK整合。 独挑大梁，独自启动不需要依赖其它组件。 Eureka，服务注册中心，特性有失效剔除、服务保护。 Dashboard，Hystrix仪表盘，监控集群模式和单点模式，其中集群模式需要收集器Turbine配合。 Zuul，API服务网关，功能有路由分发和过滤。 Config，分布式配置中心，支持本地仓库、SVN、Git、Jar包内配置等模式， 每个组件都不是平白无故的产生的，是为了解决某一特定的问题而存在。 Eureka和Ribbon，是最基础的组件，一个注册服务，一个消费服务。 Hystrix为了优化Ribbon、防止整个微服务架构因为某个服务节点的问题导致崩溃，是个保险丝的作用。 Dashboard给Hystrix统计和展示用的，而且监控服务节点的整体压力和健康情况。 Turbine是集群收集器，服务于Dashboard的。 Feign是方便我们程序员些更优美的代码的。 Zuul是加在整个微服务最前沿的防火墙和代理器，隐藏微服务结点IP端口信息，加强安全保护的。 Config是为了解决所有微服务各自维护各自的配置，设置一个同意的配置中心，方便修改配置的。 Bus是因为config修改完配置后各个结点都要refresh才能生效实在太麻烦，所以交给bus来通知服务节点刷新配置的。 Stream是为了简化研发人员对MQ使用的复杂度，弱化MQ的差异性，达到程序和MQ松耦合。 Sleuth是因为单次请求在微服务节点中跳转无法追溯，解决任务链日志追踪问题的。 特殊成员Zipkin，之所以特殊是因为从jar包和包名来看它不属于Spring Cloud的一员，但是它与Spring Cloud Sleuth的抽样日志结合的天衣无缝。乍一看它与Hystrix的Dashboard作用有重叠的部分，但是他们的侧重点完全不同。Dashboard侧重的是单个服务的统计和是否可用，Zipkin侧重的监控环节时长。简言之，Dashboard侧重故障诊断，Ziokin侧重性能优化。","tags":[{"name":"SpringCloud","slug":"SpringCloud","permalink":"https://www.superlee.wang/tags/SpringCloud/"}]},{"title":"拜占庭将军问题","date":"2018-10-12T12:59:05.000Z","path":"2018/10/12/拜占庭将军问题/","text":"","tags":[]},{"title":"工作量证明原理","date":"2018-10-12T12:58:53.000Z","path":"2018/10/12/工作量证明原理/","text":"(function(w,d,s,l,i){w[l]=w[l]||[];w[l].push({‘gtm.start’:new Date().getTime(),event:’gtm.js’});var f=d.getElementsByTagName(s)[0],j=d.createElement(s),dl=l!=’dataLayer’?’&amp;l=’+l:’’;j.async=true;j.src=‘https://www.googletagmanager.com/gtm.js?id=&#39;+i+dl;f.parentNode.insertBefore(j,f);})(window,document,’script’,’dataLayer’,’GTM-PDHPFLQ’);","tags":[]},{"title":"八皇后问题递归算法","date":"2018-10-12T12:07:05.000Z","path":"2018/10/12/八皇后问题递归算法/","text":"八皇后问题的递归实现： package com.woqu.payment.constant; import java.util.ArrayList;import java.util.List; public class NQueenProblem { private static int n=8;//n皇后问题 private static int total=0;//解法计数 /** * 递归算法分析皇后可占位情况 * @param queen */ public static void analyse(List&lt;Integer[]&gt; queen){ if(queen==null){ queen = new ArrayList&lt;Integer[]&gt;(); } int length = queen.size(); boolean[] rank = render(queen); Integer[] currentqueen={-1, -1}; for(int i=0; i&lt;n; i++){ if(rank[i]){//满足条件 currentqueen[0]=i; currentqueen[1]=length; queen.add(currentqueen); if(length==n-1){//到达最后一行 total++; print(queen); } else{ analyse(queen);//递归分析下一皇后的占位 } queen.remove(currentqueen);//恢复上次递归时的占位状态 } } } /** * 根据当前皇后占位情况返回下一行中皇后的可占位情况 * @param queen * @return */ public static boolean[] render(List&lt;Integer[]&gt; queen){ boolean[] rank = new boolean[n]; for(int i=0; i&lt;n; i++){ rank[i]=true; } int y = 0; if(queen!=null){ y = queen.size(); } for(int x=0; x&lt;n; x++){ for(int i=0; i&lt;y; i++){ if(x==queen.get(i)[0]|| x-queen.get(i)[0]==y-queen.get(i)[1]|| x-queen.get(i)[0]==queen.get(i)[1]-y){ rank[x]=false; break; } } } return rank; } /** * 占位可视化 * @param queen */ public static void print(List&lt;Integer[]&gt; queen){ System.out.println(&quot;--------&quot;); for(int y=0; y&lt;queen.size(); y++){ for(int x=0; x&lt;queen.size(); x++){ if(x==queen.get(y)[0] &amp;&amp; y== queen.get(y)[1]){ System.out.print(&quot;o &quot;); } else{ System.out.print(&quot;x &quot;); } } System.out.println(); } System.out.println(&quot;--------&quot;); } public static void main(String[] args) { long time1 = System.currentTimeMillis(); NQueenProblem.n=8; NQueenProblem.total=0; analyse(null); System.out.println(&quot;solutions: &quot;+total); long time2 = System.currentTimeMillis(); System.out.println(&quot;spent time: &quot;+(time2-time1)+&quot;ms&quot;); } }","tags":[{"name":"算法，递归","slug":"算法，递归","permalink":"https://www.superlee.wang/tags/算法，递归/"}]},{"title":"支付系统开发过程中遇到的问题总结","date":"2018-06-29T10:04:49.000Z","path":"2018/06/29/支付系统开发过程中遇到的问题总结/","text":"支付系统中可能会遇到的问题包括：有空再写。。。","tags":[{"name":"开发问题总结","slug":"开发问题总结","permalink":"https://www.superlee.wang/tags/开发问题总结/"}]},{"title":"hey,man","date":"2018-06-15T02:31:14.000Z","path":"2018/06/15/hey-man/","text":"hey~","tags":[{"name":"哈哈","slug":"哈哈","permalink":"https://www.superlee.wang/tags/哈哈/"}]},{"title":"Hello World","date":"2016-06-11T08:15:41.000Z","path":"2016/06/11/hello-world/","text":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new \"My New Post\" More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment","tags":[]}]